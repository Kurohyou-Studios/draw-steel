mixin cutWrapper(elem='div')
  #{elem}.cutWrapper&attributes(attributes)
    .cut-container
      block
mixin cutInput(inputObj)
  - inputObj.type = inputObj.type || 'text';
  .cutWrapper&attributes(attributes)
    +input(inputObj).cut-container
mixin cutSelect(inputObj)
  .cutWrapper&attributes(attributes)
    +select(inputObj).cut-container
      block
mixin cutLabel({inputObj,spanObj})
  +cutWrapper('label')&attributes(attributes)
    .input-label.stacked
      span&attributes(spanObj).input-label__text
      +input(inputObj).input-label__input
mixin cutSelectLabel({inputObj,spanObj})
  +cutWrapper('label')&attributes(attributes)
    .input-label.stacked
      span&attributes(spanObj).input-label__text
      +select(inputObj).input-label__input
        block
mixin headedCut
  - const headObj = {};
  - const contentObj = {};
  mixin header
    - headObj.block = block;
    - headObj.attributes = attributes;
  mixin content
    - contentObj.block = block;
    - contentObj.attributes = attributes;
  .headed-cut&attributes(attributes)
    - block && block();
    .cut-header&attributes(headObj.attributes)
      - headObj.block && headObj.block();
    .cutWrapper
      .cut-container&attributes(attributes)
        - contentObj.block && contentObj.block();
+scss.
  .headed-cut{
    --_headerAdjust: 10px;
    display: grid;
    grid-template-columns: [head-start content-start] 1fr [head-end content-end];
    grid-template-rows: 
      [head-start]
      auto
      [head-end content-start]
      auto
      1fr
      [content-end];
    > .cut-header{
      grid-area: head;
      place-self: center;
      background-color: var(--backColor);
      padding-inline: var(--half-gap);
      position: relative;
      top: var(--_headerAdjust);
      z-index: 10;
      margin-top: calc(var(--_headerAdjust) * -1);
    }
    > .cutWrapper{
      grid-area: content;
      > .cut-container{
        padding-top: calc(var(--_clipSize) * 2);
      }
    }
  }
  .cutWrapper{
    --notchSize: 3px;
    --notchBorderSize: 2px;
    --_clipSize: calc(var(--notchSize) * 1.7072135785);
    display: grid;
    grid-template-areas: 'content';
    clip-path: polygon(
      var(--_clipSize) 0, calc(100% - var(--_clipSize)) 0,
      100% var(--_clipSize), 100% calc(100% - var(--_clipSize)),
      calc(100% - var(--_clipSize)) 100%, var(--_clipSize) 100%,
      0 calc(100% - var(--_clipSize)), 0 var(--_clipSize)
      );
    > .cut-container{
      grid-area: content;
      background-color: var(--inputBack);
      border: var(--notchBorderSize) solid var(--borderColor);
      &:not(input):not(select){
        padding: var(--_clipSize);
      }
      &:checked{
        --checkedBackColor: var(--borderColor);
        &:before{
          display: none;
        }
      }
    }
    &:after{
      --_nS: var(--notchSize);
      --_bS: var(--notchBorderSize);
      content: '';
      grid-area: content;
      background: {
        image:
          linear-gradient(45deg,var(--borderColor) calc(var(--_nS) + var(--_bS)),transparent calc(var(--_nS) + var(--_bS))),
          linear-gradient(135deg,var(--borderColor) calc(var(--_nS) + var(--_bS)),transparent calc(var(--_nS) + var(--_bS))),
          linear-gradient(225deg,var(--borderColor) calc(var(--_nS) + var(--_bS)),transparent calc(var(--_nS) + var(--_bS))),
          linear-gradient(315deg,var(--borderColor) calc(var(--_nS) + var(--_bS)),transparent calc(var(--_nS) + var(--_bS)));
      };
      pointer-events: none;
    }
  }
  .notched-checkbox{
    aspect-ratio: 1 / 1;
  }